// backend/controllers/saleController.js
// This file handles all sales-related API logic.
// It interacts with the Supabase database.

const supabase = require('../config/supabaseClient'); // Import the Supabase client
const PDFDocument = require('pdfkit'); // For PDF generation
const fs = require('fs'); // Node.js file system module

// --- SALES API CONTROLLERS ---

// Create a new sale (header and line items)
exports.createSale = async (req, res) => {
    console.log(`[${new Date().toISOString()}] POST /api/sales called. Body:`, JSON.stringify(req.body, null, 2)); // Log full body with pretty print
    const { line_items, ...saleHeaderData } = req.body;

    // --- VERIFIED FIX FOR SUBTOTAL AND OTHER NUMERIC FIELDS ---
    // Log for debugging the incoming subtotal
    console.log(`[DEBUG - createSale] Received saleHeaderData:`, saleHeaderData);
    console.log(`[DEBUG - createSale] Received line_items:`, line_items);
    console.log(`[DEBUG - createSale] Received subtotal from frontend: ${saleHeaderData.subtotal}, Type: ${typeof saleHeaderData.subtotal}`);

    // Parse and validate subtotal from incoming request body
    // Using `|| 0` ensures that if subtotal is undefined, null, or empty string, it defaults to 0
    // before parseFloat, preventing NaN issues for missing/empty fields.
    const parsedSubtotal = parseFloat(saleHeaderData.subtotal || 0);

    // Basic validation for sale header required fields
    // This check now correctly handles if subtotal is missing or evaluates to NaN
    if (!saleHeaderData.sale_date || !saleHeaderData.customer_name || !saleHeaderData.payment_method ||
        isNaN(parsedSubtotal)) { // Check if parsedSubtotal is NaN
        console.error(`[ERROR - createSale] Missing or invalid required sale header fields:
            sale_date: ${saleHeaderData.sale_date},
            customer_name: ${saleHeaderData.customer_name},
            payment_method: ${saleHeaderData.payment_method},
            subtotal (parsed): ${parsedSubtotal},
            isNaN(parsedSubtotal): ${isNaN(parsedSubtotal)}
        `);
        return res.status(400).json({ message: 'Missing or invalid required sale header fields: sale_date, customer_name, payment_method, subtotal must be a valid number.' });
    }

    if (!Array.isArray(line_items) || line_items.length === 0) {
        return res.status(400).json({ message: 'Sale must include at least one line item.' });
    }

    try {
        // 1. Insert into sale_header
        const headerInsertData = {
            sale_date: saleHeaderData.sale_date,
            customer_name: saleHeaderData.customer_name,
            contact_type: saleHeaderData.contact_type || null,
            contact_info: saleHeaderData.contact_info || null,
            payment_method: saleHeaderData.payment_method,
            // Use parseFloat and default to 0 if the original value is not a valid number (e.g., null, undefined, "")
            discount_percent: parseFloat(saleHeaderData.discount_percent || 0),
            tax_amount: parseFloat(saleHeaderData.tax_amount || 0),
            transaction_fee: parseFloat(saleHeaderData.transaction_fee || 0),
            subtotal: parsedSubtotal, // Use the already parsed and validated subtotal
            invoice_number: saleHeaderData.invoice_number || null,
            notes: saleHeaderData.notes || null,
        };

        const { data: headerData, error: headerError } = await supabase
            .from('sale_header')
            .insert([headerInsertData])
            // Select all relevant columns from headerData including the ones that are generated by DB functions
            .select('id, invoice_number, subtotal, discount_amount, total_amount, tax_amount, transaction_fee');

        if (headerError) {
            console.error("Supabase Error - createSale (header):", headerError);
            // Log full Supabase error for better debugging
            if (headerError.details) console.error("Supabase Error Details:", headerError.details);
            if (headerError.hint) console.error("Supabase Error Hint:", headerError.hint);
            return res.status(500).json({ message: 'Error creating sale header', error: headerError.message });
        }

        const sale_header_id = headerData[0].id;
        const invoice_number = headerData[0].invoice_number;
        // These are now guaranteed to be numbers as they come from the DB after insert
        // const calculatedSubtotal = headerData[0].subtotal; // Already used parsedSubtotal
        // const calculatedDiscountAmount = headerData[0].discount_amount;
        // const calculatedTotalAmount = headerData[0].total_amount;
        // const calculatedTaxAmount = headerData[0].tax_amount;
        // const calculatedTransactionFee = headerData[0].transaction_fee;


        // 2. Prepare line items for batch insert into sale_items
        const lineItemsToInsert = line_items.map(item => {
            const unitPrice = parseFloat(item.unit_price);
            const quantity = parseInt(item.quantity);
            const commissionRate = parseFloat(item.commission_rate || 0); // Get commission_rate from the item

            // Calculate the commission here based on unit_price, quantity, and commission_rate
            const calculatedCommission = unitPrice * quantity * commissionRate; // This is the amount for the consignor

            return {
                sale_id: sale_header_id,
                product_id: parseInt(item.product_id), // Ensure product_id is an integer
                consignor_id: parseInt(item.consignor_id), // Ensure consignor_id is an integer
                agreement_id: item.agreement_id ? parseInt(item.agreement_id) : null, // Handle optional agreement_id
                quantity: quantity, // Ensure quantity is an integer
                unit_price: unitPrice, // Ensure unit_price is a float
                commission: calculatedCommission, // Use the calculated commission. This is the source for commission tracking!
            };
        });

        // Insert sale_items and select the inserted data including UUIDs and calculated fields
        const { data: lineData, error: lineError } = await supabase
            .from('sale_items')
            .insert(lineItemsToInsert)
            .select('id, product_id, quantity, unit_price, commission, line_total, consignor_id, agreement_id'); // Select inserted data to use for commission_items

        if (lineError) {
            console.error("Supabase Error - createSale (line items):", lineError);
            // Log full Supabase error for better debugging
            if (lineError.details) console.error("Supabase Error Details:", lineError.details);
            if (lineError.hint) console.error("Supabase Error Hint:", lineError.hint);
            // IMPORTANT: Rollback the header if line item insertion fails to maintain data integrity
            await supabase.from('sale_header').delete().eq('id', sale_header_id);
            return res.status(500).json({ message: 'Error creating sale line items. Sale header rolled back.', error: lineError.message });
        }

        console.log(`[${new Date().toISOString()}] Sale created successfully with ID: ${sale_header_id}, Invoice: ${invoice_number}`);

        // --- NEW LOGIC FOR COMMISSION TRACKING AND COMMISSION ITEMS ---
        // This logic runs after sale_items are successfully inserted.

        const saleDate = new Date(saleHeaderData.sale_date); // Use the sale_date from the header
        // Define the commission period (e.g., first day of the month to last day of the month)
        const periodStart = new Date(saleDate.getFullYear(), saleDate.getMonth(), 1).toISOString().split('T')[0];
        const periodEnd = new Date(saleDate.getFullYear(), saleDate.getMonth() + 1, 0).toISOString().split('T')[0];

        // Process each sale item to update commission_tracking and insert commission_items
        for (const saleItem of lineData) { // Iterate over the successfully inserted sale_items
            const consignorId = saleItem.consignor_id;
            const productSaleAmount = saleItem.line_total; // The total price of this specific product in the sale
            const commissionAmount = saleItem.commission; // The calculated commission for this specific product

            // Retrieve the original commission_rate from the request line_items (or fetch from agreements if not present)
            // It's important to use the rate that was actually used for calculation
            const originalLineItem = line_items.find(item => parseInt(item.product_id) === saleItem.product_id && parseInt(item.consignor_id) === saleItem.consignor_id);
            const commissionRate = parseFloat(originalLineItem?.commission_rate || 0); // Use optional chaining in case item isn't found (shouldn't happen)

            let commissionTrackingId;

            // Try to find an existing commission_tracking entry for this consignor and period
            let { data: commissionTracking, error: ctFetchError } = await supabase
                .from('commission_tracking')
                .select('id, total_sales, total_commission')
                .eq('consignor_id', consignorId)
                .eq('period_start', periodStart)
                .eq('period_end', periodEnd)
                .single();

            if (ctFetchError && ctFetchError.code !== 'PGRST116') { // PGRST116 means no rows found, which is expected for new periods
                console.error(`[ERROR - Commission Tracking] Supabase Error fetching commission_tracking for consignor ${consignorId}:`, ctFetchError);
                // Decide if you want to abort the sale or just log this error.
                // For now, it will log and proceed, but this could lead to inconsistent commission data.
            }

            if (commissionTracking) {
                // If a tracking record exists, update it
                const { data: updatedCt, error: updateCtError } = await supabase
                    .from('commission_tracking')
                    .update({
                        total_sales: parseFloat(commissionTracking.total_sales) + productSaleAmount,
                        total_commission: parseFloat(commissionTracking.total_commission) + commissionAmount,
                        // 'updated_at' is handled by the moddatetime trigger
                    })
                    .eq('id', commissionTracking.id)
                    .select('id') // Select ID to confirm update
                    .single();

                if (updateCtError) {
                    console.error(`[ERROR - Commission Tracking] Supabase Error updating commission_tracking for ID ${commissionTracking.id}:`, updateCtError);
                } else {
                    commissionTrackingId = updatedCt.id;
                    console.log(`[${new Date().toISOString()}] Updated commission_tracking for consignor ${consignorId} (ID: ${commissionTrackingId}).`);
                }
            } else {
                // If no tracking record exists for this period, create a new one
                const { data: newCt, error: newCtError } = await supabase
                    .from('commission_tracking')
                    .insert({
                        consignor_id: consignorId,
                        period_start: periodStart,
                        period_end: periodEnd,
                        total_sales: productSaleAmount,
                        total_commission: commissionAmount,
                        status: 'pending' // Initial status for a new tracking period
                    })
                    .select('id') // Select the ID of the newly created record
                    .single();

                if (newCtError) {
                    console.error(`[ERROR - Commission Tracking] Supabase Error creating new commission_tracking for consignor ${consignorId}:`, newCtError);
                } else {
                    commissionTrackingId = newCt.id;
                    console.log(`[${new Date().toISOString()}] Created new commission_tracking for consignor ${consignorId} (ID: ${commissionTrackingId}).`);
                }
            }

            // After ensuring a commission_tracking_id exists, insert into commission_items
            if (commissionTrackingId) {
                const { error: ciInsertError } = await supabase
                    .from('commission_items')
                    .insert({
                        commission_tracking_id: commissionTrackingId,
                        sale_item_id: saleItem.id, // The UUID of the sale_item that was just created
                        product_id: saleItem.product_id,
                        sale_amount: productSaleAmount,
                        commission_rate: commissionRate,
                        commission_amount: commissionAmount,
                    });

                if (ciInsertError) {
                    console.error(`[ERROR - Commission Items] Supabase Error inserting commission_item for sale_item ${saleItem.id}:`, ciInsertError);
                } else {
                    console.log(`[${new Date().toISOString()}] Inserted commission_item for sale_item ${saleItem.id}.`);
                }
            } else {
                console.warn(`[WARNING - Commission Items] Could not insert commission_item for sale_item ${saleItem.id} as commission_tracking_id was not obtained.`);
            }
        }
        // --- END NEW LOGIC FOR COMMISSION TRACKING AND COMMISSION ITEMS ---


        // Fetch the newly created sale with joined data for immediate frontend response
        const { data: newSaleData, error: fetchNewSaleError } = await supabase
            .from('sale_header')
            .select(`
                id,
                sale_date,
                payment_method,
                customer_name,
                invoice_number,
                notes,
                subtotal,
                discount_amount,
                total_amount,
                tax_amount,
                transaction_fee,
                sale_items (
                    product_id,
                    quantity,
                    unit_price,
                    commission,
                    line_total,
                    products(name),
                    consignors(full_name, id)
                )
            `)
            .eq('id', sale_header_id)
            .single();

        if (fetchNewSaleError) {
            console.error("Supabase Error - createSale (fetching new sale for response):", fetchNewSaleError);
            return res.status(500).json({ message: 'Sale recorded, but failed to retrieve full sale data for response.', error: fetchNewSaleError.message });
        }

        // Aggregate data for frontendSale object
        let totalCommission = 0;
        let productNameForDisplay = 'Multiple Products';
        let consignorNameForDisplay = 'Multiple Consignors';
        let consignorIdForDisplay = null;


        if (newSaleData.sale_items && newSaleData.sale_items.length > 0) {
            newSaleData.sale_items.forEach(item => {
                totalCommission += item.commission;
            });

            // If only one item, get specific product/consignor name and ID
            if (newSaleData.sale_items.length === 1) {
                productNameForDisplay = newSaleData.sale_items[0].products?.name || 'N/A';
                consignorNameForDisplay = newSaleData.sale_items[0].consignors?.full_name || 'N/A';
                consignorIdForDisplay = newSaleData.sale_items[0].consignors?.id || null;
            }
        }

        const frontendSale = {
            id: newSaleData.id,
            saleDate: newSaleData.sale_date,
            paymentMethod: newSaleData.payment_method,
            customerName: newSaleData.customer_name,
            productName: productNameForDisplay,
            amount: newSaleData.total_amount, // Use the total_amount calculated by the DB
            commission: totalCommission, // Sum of commissions from line items
            consignorId: consignorIdForDisplay, // Consignor ID for display (if single product)
            consignorName: consignorNameForDisplay,
            subtotal: newSaleData.subtotal,
            discountAmount: newSaleData.discount_amount,
            taxAmount: newSaleData.tax_amount,
            transactionFee: newSaleData.transaction_fee,
            invoiceNumber: newSaleData.invoice_number,
            notes: newSaleData.notes,
            lineItems: newSaleData.sale_items,
        };

        res.status(201).json({
            message: 'Sale recorded successfully!',
            saleId: sale_header_id,
            invoiceNumber: invoice_number,
            newSale: frontendSale
        });

    } catch (err) {
        console.error("Server Error - createSale (Catch Block):", err);
        res.status(500).json({ message: 'Internal server error', error: err.message });
    }
};

// Get all sales with their line items, products, and consignor details
exports.getAllSales = async (req, res) => {
    console.log(`[${new Date().toISOString()}] GET /api/sales called.`);
    try {
        // Fetch sales data, joining all necessary tables
        const { data: salesData, error } = await supabase
            .from('sale_header')
            .select(`
                id,
                sale_date,
                customer_name,
                payment_method,
                subtotal,
                discount_percent,
                discount_amount,
                tax_amount,
                transaction_fee,
                total_amount,
                sale_items!inner (
                    product_id,
                    quantity,
                    unit_price,
                    commission,
                    line_total,
                    net_amount,
                    products!inner (
                        id,
                        name,
                        consignor_id,
                        consignors!inner (
                            id,
                            full_name
                        )
                    )
                )
            `)
            .order('sale_date', { ascending: false }); // Order by newest sales first

        if (error) {
            console.error("Supabase Error - getAllSales:", error);
            return res.status(500).json({ message: 'Error fetching sales from database', error: error.message });
        }

        // Transform the fetched data into the `Sale` interface structure expected by the frontend
        const transformedSales = salesData.map(header => {
            let productName = "Multiple Products";
            let consignorName = "Multiple Consignors";
            let consignorId = null;
            let firstProduct = true;

            let totalCommission = 0;

            if (header.sale_items && header.sale_items.length > 0) {
                header.sale_items.forEach(lineItem => {
                    totalCommission += lineItem.commission;

                    // This logic assumes `products` and `consignors` are always available for inner joins
                    if (firstProduct && lineItem.products) {
                        productName = lineItem.products.name;
                        consignorName = lineItem.products.consignors?.full_name || 'Unknown';
                        consignorId = lineItem.products.consignors?.id || null;
                        firstProduct = false; // Only get first product's details if there are multiple
                    }
                });
            } else {
                productName = "No Products";
                consignorName = "N/A";
            }

            return {
                id: header.id,
                saleDate: header.sale_date,
                productName: productName,
                consignorName: consignorName,
                amount: header.total_amount,
                commission: totalCommission, // Aggregated commission
                paymentMethod: header.payment_method,
                consignorId: consignorId, // Consignor ID for display (if single product)
                subtotal: header.subtotal,
                discountPercent: header.discount_percent,
                discountAmount: header.discount_amount,
                taxAmount: header.tax_amount,
                transactionFee: header.transaction_fee,
                lineItems: header.sale_items.map(item => ({
                    productId: item.product_id,
                    quantity: item.quantity,
                    unitPrice: item.unit_price,
                    commission: item.commission,
                    lineTotal: item.line_total,
                    netAmount: item.net_amount,
                    productName: item.products?.name,
                    consignorName: item.products?.consignors?.full_name,
                })),
            };
        });

        console.log(`[${new Date().toISOString()}] Returning ${transformedSales.length} transformed sales from DB.`);
        res.status(200).json(transformedSales);
    } catch (err) {
        console.error("Server Error - getAllSales:", err);
        res.status(500).json({ message: 'Internal server error', error: err.message });
    }
};

// Get a single sale by ID with its line items
exports.getSaleById = async (req, res) => {
    const saleId = req.params.id;
    console.log(`[${new Date().toISOString()}] GET /api/sales/${saleId} called.`);

    // UUID validation
    if (!/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/.test(saleId)) {
        return res.status(400).json({ message: 'Invalid Sale ID format (must be a UUID).' });
    }

    try {
        const { data, error } = await supabase
            .from('sale_header')
            .select(`
                *,
                sale_items (
                    *,
                    products (name),       // Join products to get product name
                    consignors (full_name) // Join consignors to get consignor name
                )
            `)
            .eq('id', saleId)
            .single();

        if (error) {
            console.error(`Supabase Error - getSaleById for ID ${saleId}:`, error);
            if (error.code === 'PGRST116') { // Supabase code for "No rows found"
                return res.status(404).json({ message: `Sale with ID ${saleId} not found.` });
            }
            return res.status(500).json({ message: 'Error fetching sale from database', error: error.message });
        }

        if (!data) { // Should be caught by PGRST116, but good defensive check
            return res.status(404).json({ message: `Sale with ID ${saleId} not found.` });
        }

        console.log(`[${new Date().toISOString()}] Returning sale with ID ${saleId}:`, data);
        res.status(200).json(data);
    } catch (err) {
        console.error("Server Error - getSaleById:", err);
        res.status(500).json({ message: 'Internal server error', error: err.message });
    }
};

// Update an existing sale header by ID
exports.updateSaleHeader = async (req, res) => {
    const saleId = req.params.id;
    const updateData = req.body;
    console.log(`[${new Date().toISOString()}] PUT /api/sales/${saleId} called. Update data:`, updateData);

    // UUID validation
    if (!/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/.test(saleId)) {
        return res.status(400).json({ message: 'Invalid Sale ID format (must be a UUID).' });
    }

    const allowedFields = [
        'sale_date', 'customer_name', 'contact_type', 'contact_info',
        'payment_method', 'discount_percent', 'tax_amount', 'transaction_fee',
        'subtotal', 'invoice_number', 'notes'
    ];
    const fieldsToUpdate = {};
    let hasValidField = false;

    for (const field of allowedFields) {
        if (updateData[field] !== undefined) { // Check if field exists in updateData
            if (['discount_percent', 'tax_amount', 'transaction_fee', 'subtotal'].includes(field)) {
                // Parse numeric fields and validate, similar to createSale
                const parsedValue = parseFloat(updateData[field]);
                if (isNaN(parsedValue)) {
                    return res.status(400).json({ message: `Invalid numeric value for field: ${field}. Value received: "${updateData[field]}"` });
                }
                fieldsToUpdate[field] = parsedValue;
            } else {
                fieldsToUpdate[field] = updateData[field];
            }
            hasValidField = true;
        }
    }

    if (!hasValidField) {
        return res.status(400).json({ message: 'No valid fields provided for sale header update.' });
    }

    try {
        const { data, error } = await supabase
            .from('sale_header')
            .update(fieldsToUpdate)
            .eq('id', saleId)
            .select('*'); // Select the updated row

        if (error) {
            console.error(`Supabase Error - updateSaleHeader for ID ${saleId}:`, error);
            if (error.code === '23505' && error.constraint === 'sale_header_invoice_number_key') {
                return res.status(409).json({ message: 'Invoice number already exists.', error: error.message });
            }
            return res.status(500).json({ message: 'Error updating sale header in database', error: error.message });
        }

        if (data.length === 0) { // If no row was found and updated
            return res.status(404).json({ message: `Sale with ID ${saleId} not found.` });
        }

        console.log(`[${new Date().toISOString()}] Sale header ID ${saleId} updated in DB:`, data[0]);
        res.status(200).json(data[0]);
    } catch (err) {
        console.error("Server Error - updateSaleHeader:", err);
        res.status(500).json({ message: 'Internal server error', error: err.message });
    }
};

// Delete a sale by ID (cascades to line items)
exports.deleteSale = async (req, res) => {
    const saleId = req.params.id;
    console.log(`[${new Date().toISOString()}] DELETE /api/sales/${saleId} called.`);

    // UUID validation
    if (!/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/.test(saleId)) {
        return res.status(400).json({ message: 'Invalid Sale ID format (must be a UUID).' });
    }

    try {
        const { data, error } = await supabase
            .from('sale_header')
            .delete()
            .eq('id', saleId)
            .select('id'); // Select ID to confirm deletion

        if (error) {
            console.error(`Supabase Error - deleteSale for ID ${saleId}:`, error);
            return res.status(500).json({ message: 'Error deleting sale from database', error: error.message });
        }

        if (data.length === 0) { // If no row was found and deleted
            return res.status(404).json({ message: `Sale with ID ${saleId} not found.` });
        }

        // IMPORTANT: If you delete a sale, you might also want to reverse or adjust
        // the related commission_tracking and commission_items entries.
        // This current code *does not* handle that. You'd need additional logic here.
        // For example:
        // 1. Find all commission_items linked to the sale_items of this deleted sale.
        // 2. For each commission_item, subtract its sale_amount and commission_amount from the corresponding commission_tracking record.
        // 3. Delete the commission_items.
        // This is complex and might require careful transaction management or a PostgreSQL function/trigger.

        console.log(`[${new Date().toISOString()}] Sale ID ${saleId} deleted successfully (including line items due to CASCADE).`);
        res.status(204).send(); // 204 No Content for successful deletion
    } catch (err) {
        console.error("Server Error - deleteSale:", err);
        res.status(500).json({ message: 'Internal server error', error: err.message });
    }
};

// GET /api/sales/:saleId/receipt - Route to generate and download a receipt PDF
exports.generateReceiptPdf = async (req, res) => {
    const saleId = req.params.saleId;
    console.log(`[${new Date().toISOString()}] GET /api/sales/${saleId}/receipt called.`);

    // UUID validation
    if (!/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/.test(saleId)) {
        return res.status(400).json({ message: 'Invalid Sale ID format (must be a UUID).' });
    }

    try {
        const { data: sale, error: saleError } = await supabase
            .from('sale_header')
            .select(`
                *,
                sale_items (
                    *,
                    products(name),
                    consignors(full_name)
                )
            `)
            .eq('id', saleId)
            .single();

        if (saleError) {
            console.error(`Supabase Error - generateReceiptPdf (fetching sale) for ID ${saleId}:`, saleError);
            if (saleError.code === 'PGRST116') {
                return res.status(404).json({ message: `Sale with ID ${saleId} not found for receipt generation.` });
            }
            return res.status(500).json({ message: 'Error fetching sale data for receipt', error: saleError.message });
        }

        if (!sale) {
            return res.status(404).json({ message: `Sale with ID ${saleId} not found for receipt generation.` });
        }

        // --- PDF Generation Logic ---
        const doc = new PDFDocument({ margin: 50 });
        const filename = `receipt_sale_${sale.invoice_number || sale.id}.pdf`;

        // Set response headers for PDF download
        res.setHeader('Content-Type', 'application/pdf');
        res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);

        // Pipe the PDF directly to the response
        doc.pipe(res);

        // Header Section
        doc.fontSize(28)
           .font('Helvetica-Bold')
           .text('SALES RECEIPT', { align: 'center' })
           .moveDown(0.8);

        doc.fontSize(12)
           .font('Helvetica')
           .text('Consignment Owner Store', { align: 'center' })
           .text('123 Main Street, Cityville, State, 12345', { align: 'center' })
           .text('Phone: (123) 456-7890 | Email: info@consignstore.com', { align: 'center' })
           .moveDown(1);

        doc.strokeColor('#aaaaaa').lineWidth(1).moveTo(50, doc.y).lineTo(doc.page.width - 50, doc.y).stroke();
        doc.moveDown(0.8);

        // Sale Header Details
        doc.fontSize(12)
           .font('Helvetica-Bold')
           .text('Invoice Number:', { continued: true })
           .font('Helvetica')
           .text(` ${sale.invoice_number || 'N/A'}`);
        doc.fontSize(12)
           .font('Helvetica-Bold')
           .text('Sale Date:', { continued: true })
           .font('Helvetica')
           .text(` ${new Date(sale.sale_date).toLocaleDateString()} ${new Date(sale.sale_date).toLocaleTimeString()}`);
        doc.fontSize(12)
           .font('Helvetica-Bold')
           .text('Sale ID:', { continued: true })
           .font('Helvetica')
           .text(` ${sale.id}`);
        doc.moveDown(0.5);

        // Customer Details
        doc.fontSize(12)
           .font('Helvetica-Bold')
           .text('Customer Name:', { continued: true })
           .font('Helvetica')
           .text(` ${sale.customer_name || 'N/A'}`);
        if (sale.contact_type && sale.contact_info) {
            doc.fontSize(12)
               .font('Helvetica-Bold')
               .text(`Customer ${sale.contact_type}:`, { continued: true })
               .font('Helvetica')
               .text(` ${sale.contact_info}`);
        }
        doc.moveDown(1);

        doc.strokeColor('#aaaaaa').lineWidth(1).moveTo(50, doc.y).lineTo(doc.page.width - 50, doc.y).stroke();
        doc.moveDown(0.8);

        // Line Items Table Header
        const itemTableTop = doc.y;
        const col1X = 50; // Qty
        const col2X = 100; // Item Name
        const col3X = 350; // Unit Price
        const col4X = 450; // Total

        doc.font('Helvetica-Bold')
           .fontSize(12)
           .text('Qty', col1X, itemTableTop, { width: 50 })
           .text('Item', col2X, itemTableTop, { width: 250 })
           .text('Unit Price', col3X, itemTableTop, { width: 100, align: 'right' })
           .text('Total', col4X, itemTableTop, { width: 100, align: 'right' });

        doc.moveDown(0.5);
        doc.strokeColor('#aaaaaa').lineWidth(1).moveTo(50, doc.y).lineTo(doc.page.width - 50, doc.y).stroke();
        doc.moveDown(0.3);

        // Line Items Content
        doc.font('Helvetica').fontSize(11);
        sale.sale_items.forEach(item => {
            // Use product name if available from join, otherwise fallback
            const itemProductName = item.products?.name || `Product ID: ${item.product_id}`;
            const itemTotal = item.line_total.toFixed(2);
            doc.text(item.quantity.toString(), col1X, doc.y, { width: 50 });
            doc.text(itemProductName, col2X, doc.y, { width: 250 });
            doc.text(`$${item.unit_price.toFixed(2)}`, col3X, doc.y, { width: 100, align: 'right' });
            doc.text(`$${itemTotal}`, col4X, doc.y, { width: 100, align: 'right' });
            doc.moveDown(0.5);
        });

        doc.strokeColor('#aaaaaa').lineWidth(1).moveTo(50, doc.y).lineTo(doc.page.width - 50, doc.y).stroke();
        doc.moveDown(0.8);

        // Financial Summary
        doc.font('Helvetica').fontSize(12);
        doc.text('Subtotal:', 350, doc.y, { width: 100, align: 'right', continued: true })
           .text(`$${sale.subtotal.toFixed(2)}`, 450, doc.y, { width: 100, align: 'right' })
           .moveDown(0.2);

        if (sale.discount_amount && sale.discount_amount > 0) {
            doc.text(`Discount (${sale.discount_percent}%):`, 350, doc.y, { width: 100, align: 'right', continued: true })
               .text(`-$${sale.discount_amount.toFixed(2)}`, 450, doc.y, { width: 100, align: 'right' })
               .moveDown(0.2);
        }

        doc.text('Tax Amount:', 350, doc.y, { width: 100, align: 'right', continued: true })
           .text(`$${sale.tax_amount.toFixed(2)}`, 450, doc.y, { width: 100, align: 'right' })
           .moveDown(0.2);

        doc.text('Transaction Fee:', 350, doc.y, { width: 100, align: 'right', continued: true })
           .text(`$${sale.transaction_fee.toFixed(2)}`, 450, doc.y, { width: 100, align: 'right' })
           .moveDown(0.5);

        doc.font('Helvetica-Bold').fontSize(16);
        doc.text('GRAND TOTAL:', 350, doc.y, { width: 100, align: 'right', continued: true })
           .text(`$${sale.total_amount.toFixed(2)}`, 450, doc.y, { width: 100, align: 'right' })
           .moveDown(1);

        doc.strokeColor('#aaaaaa').lineWidth(1).moveTo(50, doc.y).lineTo(doc.page.width - 50, doc.y).stroke();
        doc.moveDown(0.8);

        // Footer Information
        doc.font('Helvetica').fontSize(12);
        doc.text(`Payment Method: ${sale.payment_method}`).moveDown(0.5);
        if (sale.notes) {
            doc.font('Helvetica-Bold').text('Notes:').moveDown(0.2);
            doc.font('Helvetica').text(sale.notes).moveDown(0.5);
        }

        doc.font('Helvetica-Oblique').fontSize(10).text('Thank you for your purchase!', { align: 'center', absoluteBottom: 50 });

        doc.end(); // Finalize the PDF
        // --- End PDF Generation Logic ---

    } catch (err) {
        console.error("Server Error - generateReceiptPdf:", err);
        res.status(500).json({ message: 'Internal server error', error: err.message });
    }
};